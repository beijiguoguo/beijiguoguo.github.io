---
title: "MySQL锁及事务"
subtitle: ""
layout: post
author: "Aug"
header-style: text
tags:
  - MySQL
---

## 1、mysql锁

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g9ep97za9sj31nb0u0jy9.jpg)

### 乐观锁：程序实现

> 个人理解类似于CAS操作，通常加一个版本号或时间戳字段，读数据时连同该字段一起读出，更新时匹配该字段与数据库中当前字段值是否一致，一致就可以更新，否则认为数据已过期，不可以更新。

### 悲观锁：数据库提供锁机制

> 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止其它事务修改数据。如果一个事务执行的操作应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。

#### 表级锁

##### 表锁

> 表锁的优势：开销小；加锁快；无死锁
> 表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低
> 加锁的方式：自动加锁。查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。也可以显示加锁：
> 共享读锁：lock table tableName read;
> 独占写锁：lock table tableName write;
> 批量解锁：unlock tables;

- 共享读锁：

```mysql
1、session1: lock table mylock read; -- 给mylock表加读锁
2、session1: select * from mylock; -- 可以查询
3、session1:select * from tdep; --不能访问非锁定表
4、session2:select * from mylock; -- 可以查询 没有锁
5、session2:update mylock set name='x' where id=2; -- 修改阻塞,自动加行写锁 6、session1:unlock tables; -- 释放表锁
7、session2:Rows matched: 1 Changed: 1 Warnings: 0 -- 修改执行完成 8、session1:select * from tdep; --可以访问
```

- 排他写锁：

```mysql
1、session1: lock table mylock write; -- 给mylock表加写锁 2、session1: select * from mylock; -- 可以查询 3、session1:select * from tdep; --不能访问非锁定表 4、session1:update mylock set name='y' where id=2; --可以执行 5、session2:select * from mylock; -- 查询阻塞 6、session1:unlock tables; -- 释放表锁
7、session2:4 rows in set (22.57 sec) -- 查询执行完成 8、session1:select * from tdep; --可以访问
```



##### 元数据锁

> MDL不需要显式使用，在访问一个表的时候会被自动加上。MDL的作用是，保证读写的正确性。你可以想象一下， 如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。 因此，在 MySQL 5.5 版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更 操作的时候，加MDL写锁。

- 读锁之间不互斥，因此多个线程可以同时对一张表增删改查
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表 加字段，其中一个要等另一个执行完才能开始执行

```mysql
1、session1: begin; -- 开启事务
select * from mylock; -- 加MDL读锁
2、session2: alter table mylock add f int; -- 修改阻塞
3、session1：commit;  -- 提交事务 或者 rollback 释放读锁
4、session2：Query OK, 0 rows affected (38.67 sec) -- 修改完成
Records: 0 Duplicates: 0 Warnings: 0
```



#### 行级锁

> 由存储引擎InnoDB实现，通过给索引上的索引项加锁来实现的，所以只有通过索引条件检索的数据，才会加行锁，否则，将升级为表锁

##### 按锁定范围分三种

- 记录锁（Record Locks）：锁定索引中的一条记录

  - 行读锁

    - Innodb_row_lock_current_waits：当前正在等待锁定的数量
    - Innodb_row_lock_time：从系统启动到现在锁定总时间长度
    - Innodb_row_lock_time_avg：每次等待所花平均时间
    - Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间
    - Innodb_row_lock_waits：系统启动后到现在总共等待的次数

    ```mysql
    -- 查看行锁状态 
    show STATUS like 'innodb_row_lock%';
    1、session1: begin;-- 开启事务未提交
    select * from mylock where ID=1 lock in share mode; -- 手动加id=1的行读
    锁,使用索引
    2、session2：update mylock set name='y' where id=2; -- 未锁定该行可以修改
    3、session2：update mylock set name='y' where id=1; -- 锁定该行修改阻塞
    ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
    -- 锁定超时
    4、session1: commit; -- 提交事务 或者 rollback 释放读锁
    5、session2：update mylock set name='y' where id=1; -- 修改成功
    Query OK, 1 row affected (0.00 sec)
    Rows matched: 1 Changed: 1 Warnings: 0
    -- 注：使用索引加行锁 ，未锁定的行可以访问
    -- 为使用索引，升级为表锁
    ```

  - 行写锁

  ```mysql
  1、session1: begin;-- 开启事务未提交
  -- 手动加id=1的行写锁,
  select * from mylock where id=1 for update;
  2、session2：select * from mylock where id=2 ; -- 可以访问
  3、session2: select * from mylock where id=1 ; -- 可以读 不加锁
  4、session2: select * from mylock where id=1 lock in share mode ; -- 加读锁被阻塞
  5、session1：commit; -- 提交事务 或者 rollback 释放写锁
  5、session2：-- 执行成功
  -- 主键索引产生记录锁
  ```

  

- 间隙锁（Gap Locks）：锁定记录前、记录中、记录后的行

- Next-key Locks：记录锁 + 间隙锁

##### 按功能分为两种

- 共享锁S：允许一个事务去读一行，阻止其它事务获得相同数据集的排它锁
- 排它锁X：允许获得排它锁的事务更新数据，阻止其它事务对该数据集加读锁或写锁

> InnoDB会自动对Insert、Update、Delete语句加排他写锁
>
> SELECT * FROM table_name WHERE ... FOR UPDATE 可以手动加锁
>
> InnoDB不会对Selete语句加任何锁，可以显式加锁

##### 二段锁

> 传统RDBMS加锁的一个原则，就是2PL (Two-Phase Locking，二阶段锁)
>
> 锁操作分为两个阶段：加锁阶段与解锁阶段， 加锁阶段与解锁阶段不相交。
>
>  加锁阶段：只加锁，不放锁。 
>
> 解锁阶段：只放锁，不加锁。
>
> 详情参考[https://segmentfault.com/a/1190000012513286](https://segmentfault.com/a/1190000012513286)

##### 死锁

> 两个 session 互相等等待对方的资源释放之后，才能释放自己的资源,造成了死锁
>
> 并发事务应该按相同顺序加锁，否则容易死锁，如下图

![](https://tva1.sinaimg.cn/large/006y8mN6ly1g9er7csr3oj30zc0hq0zo.jpg)

```mysql
1、session1: begin;-- 开启事务未提交
-- 手动加行写锁 id=1 ，使用索引
update mylock set name='m' where id=1;
2、session2：begin;-- 开启事务未提交
-- 手动加行写锁 id=2 ，使用索引
update mylock set name='m' where id=2;
3、session1: update mylock set name='nn' where id=2; -- 加写锁被阻塞
4、session2：update mylock set name='nn' where id=1; -- 加写锁会死锁，不允许操作
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting
transaction
```



#### 意向锁

> InnoDB也实现了表级锁，也就是意向锁，意向锁是mysql内部使用的，不需要用户干预
>
> 意向锁产生的主要目的是为了处理行锁和表锁之间的冲突

- 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该 表的IS锁
- 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该 表的IX锁
- 意向锁的主要作用是为了【全表更新数据】时的性能提升。否则在全表更新数据时，需要先检索该 表是否某些记录上面有行锁

|                  | 共享锁（S） | 排它锁（X） | 意向共享锁（IS） | 意向排它锁（IX） |
| ---------------- | ----------- | ----------- | ---------------- | ---------------- |
| 共享锁（S）      | 兼容        | 冲突        | 兼容             | 冲突             |
| 排它锁（X）      | 冲突        | 冲突        | 冲突             | 冲突             |
| 意向共享锁（IS） | 兼容        | 冲突        | 兼容             | 兼容             |
| 意向排它锁（IX） | 冲突        | 冲突        | 兼容             | 兼容             |



## 2、mysql事务

> 由InnoDB实现，保证数据的完整性，保证一批sql要么全部执行要么全部不执行

### 四大特性（ACID）

- Atomicity：原子性，构成事务的所有操作是一个逻辑单元，要么全部成功，要么全部失败

- Consistency：一致性，数据库在事务执行前后应该是一致的。区别于原子性，一致性关注数据的中间状态不可见
- Isolation：隔离性，事务之间不会互相影响

	> 由锁机制和MVCC机制来实现
	>
	> MVCC：多版本并发控制，优化读写性能，读不加锁，读写不冲突

- Durability：持久性，事务执行成功必须全部落盘

### 原子性、一致性、持久性

> 通过redo log、undo log和Force Log at Commit机制实现
>

- redo log：用于崩溃时恢复数据

  > 重做日志，每次数据库的SQL操作导致的数据变化它都会记录。redo log是物理日志，记录的是数据库页的物理修改操作。如果数据发生了丢失，数据库可以根据redo log进行数据恢复 

- undo log：用于对事务的影响进行撤销，也可用于MVCC

  > 回滚日志，记录了数据在每个操作前的状态。undo log存储在回滚段中，回滚段位于共享表空间中，与存储数据库数据和索引的页类似，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。
  >
  > 因redo log是物理日志，所以undo log也会写入redo log中

  ![](https://tva1.sinaimg.cn/large/006tNbRwly1g9jj4pkzloj30vl0u0gyq.jpg)

  ​	事务进行过程中，每次sql语句执行，都会记录undo log和redo log，然后更新数据形成脏页，然后 redo log按照时间或者空间等条件进行落盘，undo log和脏页按照checkpoint进行落盘，落盘后相应的 redo log就可以删除了。此时，事务还未COMMIT，如果发生崩溃，则首先检查checkpoint记录，使用 相应的redo log进行数据和undo log的恢复，然后查看undo log的状态发现事务尚未提交，然后就使用 undo log进行事务回滚。事务执行COMMIT操作时，会将本事务相关的所有redo log都进行落盘，只有 所有redo log落盘成功，才算COMMIT成功。然后内存中的数据脏页继续按照checkpoint进行落盘。如 果此时发生了崩溃，则只使用redo log恢复数据。 

  ![](https://tva1.sinaimg.cn/large/006tNbRwly1g9jj5p9f2ij30xy0bstbc.jpg)

  

- Force Log at Commit：该机制保证事务提交后redo log日志都已经持久化

### 隔离性

#### 事务并发问题

在事务的并发操作中可能会出现一些问题: 

- 丢失更新:两个事务针对同一数据都发生修改操作时，会存在丢失更新问题。 
- 脏读:一个事务读取到另一个事务未提交的数据。 
- 不可重复读:一个事务因读取到另一个事务已提交的update或者delete数据。导致对同一条记录 读取两次以上的结果不一致。 
- 幻读:一个事务因读取到另一个事务已提交的insert数据。导致 一致。 

#### 事务隔离级别

- Read uncommitted (RU，读未提交):最低级别，任何情况都无法保证 
-  Read committed (RC，读已提交):可避免脏读的发生 
- Repeatable read (RR，可重复读):可避免脏读、不可重复读的发生 (InnoDB的RR解决了幻读，利用Next-Key锁)
- Serializable (串行化):可避免脏读、不可重复读、幻读的发生 由MVCC降级为Locking-Base CC) 

| 事务隔离级别                         | 脏读 | 不可重复读 | 幻读 |
| ------------------------------------ | ---- | ---------- | ---- |
| 读未提交(read-uncommitted)           | 是   | 是         | 是   |
| 不可重复读、读已提交(read-committed) | 否   | 是         | 是   |
| 可重复读(repeatable-read)            | 否   | 否         | 是   |
| 串行化(serializable)                 | 否   | 否         | 否   |

一个现实场景：

​		管理者要查询所有用户的存款总额，假设除了用户A和用户B之外，其他用户的存款总额都为0，A、B用户各有存款 1000，所以所有用户的存款总额为2000。但是在查询过程中，用户A会向用户B进行转账操作。转账操作和查询总额 操作的时序图如下图所示。 

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9jjb02yclj30w60ly7et.jpg)

​		如果没有任何并发控制机制，查询总额的事务先读取了A的存款，然后转账事务改变了用户A和用户B的账户 存款，最后查询总额事务继续读取了转账后的用户B的账号存款，导致最终统计的存款总额多了100元，发生错误 

```mysql
-- 创建账户表并初始化数据
create table tacount(id int , aname varchar(100),acount int , primary key(id)); alter table tacount add index idx_name(aname);
insert into tacount values(1,'a',1000);
insert into tacount values(2,'b',1000);
-- 设置隔离级读未提交(read-uncommitted)
 mysql> set session transaction isolation level read uncommitted;
 -- session 1
 mysql> start transaction ; select * from tacount where aname='a';
+----+-------+--------+ | id | aname | acount | +----+-------+--------+ |1|a |1000| +----+-------+--------+ --session 2
mysql> start transaction; update tacount set acount=1100 where aname='b';
-- session 1
mysql> select * from tacount where aname='b';
+----+-------+--------+
| id | aname | acount | +----+-------+--------+ |2|b |1100| +----+-------+--------+
```

​		使用锁机制(LBCC)可以解决上述的问题。查询总额事务会对读取的行加锁，等到操作结束后再释放所有行上的锁。因为用户A的存款被锁，导致转账操作被阻塞，直到查询总额事务提交并将所有锁都释放。 使用锁机制: 

![](https://tva1.sinaimg.cn/large/006tNbRwly1g9jjiipeo1j30wk0m07h1.jpg)

​		但是这时可能会引入新的问题，当转账操作是从用户B向用户A进行转账时会导致死锁。转账事务会先锁 住用户B的数据，等待用户A数据上的锁，但是查询总额的事务却先锁住了用户A数据，等待用户B的数 据上的锁。 

```mysql
-- 设置隔离级别为串行化(serializable) 死锁演示
mysql> set session transaction isolation level serializable;
-- session 1
mysql> start transaction;select * from tacount where aname='a';
-- session 2
mysql> start transaction ; update tacount set acount=900 where aname='b'; -- session 1
mysql> select * from tacount where aname='b';
-- session 2
mysql> update tacount set acount=1100 where aname='a';
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

​		使用MVCC机制可以解决这个问题。查询总额事务先读取了用户A的账户存款，然后转账事务会修改用户A和用户B账户存款，查询总额事务读取用户B存款时不会读取转账事务修改后的数据，而是读取本事务开始时的数据副本(在REPEATABLE READ隔离等级下)。 

​		MVCC使得数据库读不会对数据加锁，普通的SELECT请求不会加锁，提高了数据库的并发处理能力。借 助MVCC，数据库可以实现READ COMMITTED，REPEATABLE READ等隔离级别，用户可以查看当前数据的前一个或者前几个历史版本，保证了ACID中的I特性(隔离性)。 

```mysql
-- 显示当前隔离级别为 REPEATABLE-READ MySQL默认隔离级别
mysql> select @@tx_isolation;
-- session 1
mysql> start transaction ; select * from tacount where aname='a'; +----+-------+--------+
| id | aname | acount | +----+-------+--------+ |1|a |1000| +----+-------+--------+ -- session 2
mysql> start transaction; update tacount set acount=1100 where aname='a';
-- session 1
mysql> select * from tacount where aname='a';
+----+-------+--------+
| id | aname | acount | +----+-------+--------+ |1|a |1000| +----+-------+--------+ -- session 2 提交事务 mysql> commit;
-- session 1 显示在session 1 事务开始时的数据 mysql> select * from tacount where aname='a'; +----+-------+--------+
| id | aname | acount | +----+-------+--------+
|1|a |1000| +----+-------+--------+
```

```mysql
-- 设置事务隔离级别为REPEATABLE-COMMITTED 读已提交
-- session 1
mysql> set session transaction isolation level read committed;
mysql> start transaction ; select * from tacount where aname='a'; +----+-------+--------+
| id | aname | acount |
+----+-------+--------+
|1|a |1000|
+----+-------+--------+
-- session 2
mysql> set session transaction isolation level read committed;
mysql> start transaction; update tacount set acount=1100 where aname='a'; -- session 1
mysql> select * from tacount where aname='a';
+----+-------+--------+
| id | aname | acount |
+----+-------+--------+
|1|a |1000|
+----+-------+--------+
-- session 2 提交事务
mysql> commit;
-- session 1 显示最新事务提交后的数据
mysql> select * from tacount where aname='a';
+----+-------+--------+
| id | aname | acount |
+----+-------+--------+
|1|a |1100|
```



#### MVCC机制

> **Multiversion concurrency control (MCC or MVCC)**, is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory. 

##### 当前读和快照读

- 快照读：读取的是记录的可见版本（有可能是历史版本），不用加锁。简单的select属于快照读
- 当前读：读取的是记录的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会并发修改这条记录。特殊的读操作，insert/update/delete操作属于当前读

##### 一致性非锁定读

​		一致性非锁定读(consistent nonlocking read)是指InnoDB存储引擎通过多版本控制(MVCC)读取当前数 据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地， InnoDB会去读取行的一个最新可见快照。 

